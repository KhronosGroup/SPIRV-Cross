#pragma clang diagnostic ignored "-Wmissing-prototypes"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T>
struct spvDescriptor
{
    T value;
};

template<typename T>
struct spvDescriptorArray
{
    spvDescriptorArray(const device spvDescriptor<T>* ptr) : ptr(ptr)
    {
    }
    const device T& operator [] (size_t i) const
    {
        return ptr[i].value;
    }
    const device spvDescriptor<T>* ptr;
};

struct B10
{
    float v;
};

struct B11
{
    float v;
};

struct B20
{
    float v;
};

struct B21
{
    float v;
};

struct B30
{
    uint i;
};

struct B31
{
    float v;
};

constant uint3 gl_WorkGroupSize [[maybe_unused]] = uint3(1u);

struct spvDescriptorSetBuffer0
{
    array<texture2d<float>, 8> t00 [[id(0)]];
    // Overlapping binding: array<texture2d<uint>, 8> t01 [[id(0)]];
    // Overlapping binding: array<texture2d<int>, 8> t02 [[id(0)]];
    // Overlapping binding: array<texture_buffer<uint, access::read_write>, 8> u0 [[id(0)]];
    // Overlapping binding: array<sampler, 8> s00 [[id(0)]];
};

struct spvDescriptorSetBuffer1
{
    device B30* b30 [[id(0)]][1];
    // Overlapping binding: spvDescriptor<texture2d<float>> t30 [[id(0)]][1] /* unsized array hack */;
    // Overlapping binding: spvDescriptor<texture2d<uint>> t31 [[id(0)]][1] /* unsized array hack */;
    // Overlapping binding: spvDescriptor<texture2d<int>> t32 [[id(0)]][1] /* unsized array hack */;
    // Overlapping binding: array<texture_buffer<uint, access::write>, 1> u3 [[id(0)]];
    // Overlapping binding: spvDescriptor<sampler> s30 [[id(0)]][1] /* unsized array hack */;
};

struct spvDescriptorSetBuffer2
{
    device B20* b20 [[id(0)]][8];
    // Overlapping binding: array<texture2d<float>, 8> t20 [[id(0)]];
    // Overlapping binding: array<texture2d<uint>, 8> t21 [[id(0)]];
    // Overlapping binding: array<texture2d<int>, 8> t22 [[id(0)]];
    // Overlapping binding: array<texture_buffer<uint, access::read_write>, 8> u2 [[id(0)]];
    // Overlapping binding: array<sampler, 8> s20 [[id(0)]];
};

struct spvDescriptorSetBuffer3
{
    device B10* b10 [[id(0)]][8];
    // Overlapping binding: array<texture_buffer<uint, access::read_write>, 8> u1 [[id(0)]];
};

kernel void main0(const device spvDescriptorSetBuffer0& spvDescriptorSet0 [[buffer(0)]], const device spvDescriptorSetBuffer1& spvDescriptorSet1 [[buffer(1)]], constant spvDescriptorSetBuffer2& spvDescriptorSet2 [[buffer(2)]], constant spvDescriptorSetBuffer3& spvDescriptorSet3 [[buffer(3)]])
{
    spvDescriptorArray<texture2d<float>> t30 {(*(const device spvDescriptor<texture2d<float>>* device *)&spvDescriptorSet1.b30)};
    spvDescriptorArray<sampler> s30 {(*(const device spvDescriptor<sampler>* device *)&spvDescriptorSet1.b30)};
    spvDescriptorArray<texture2d<uint>> t31 {(*(const device spvDescriptor<texture2d<uint>>* device *)&spvDescriptorSet1.b30)};
    spvDescriptorArray<texture2d<int>> t32 {(*(const device spvDescriptor<texture2d<int>>* device *)&spvDescriptorSet1.b30)};

    const device auto& b31 = (constant B31* const device (&)[1])spvDescriptorSet1.b30;
    constant auto& b21 = (constant B21* constant (&)[8])spvDescriptorSet2.b20;
    constant auto& b11 = (constant B11* constant (&)[8])spvDescriptorSet3.b10;
    float4 r0 = spvDescriptorSet0.t00[0].sample((*(device array<sampler, 8>*)&spvDescriptorSet0.t00)[3], float2(0.0), level(0.0));
    r0.x = as_type<float>((*(device array<texture2d<uint>, 8>*)&spvDescriptorSet0.t00)[1].read(uint2(int2(0)), 0).x);
    r0.y = as_type<float>((*(device array<texture2d<int>, 8>*)&spvDescriptorSet0.t00)[2].read(uint2(int2(0)), 0).x);
    (*(device array<texture_buffer<uint, access::read_write>, 8>*)&spvDescriptorSet0.t00)[2].fence();
    r0.z = as_type<float>((*(device array<texture_buffer<uint, access::read_write>, 8>*)&spvDescriptorSet0.t00)[2].read(uint(0)).x);
    float4 r1;
    r1.x = spvDescriptorSet3.b10[3]->v;
    r1.y = b11[4]->v;
    (*(constant array<texture_buffer<uint, access::read_write>, 8>*)&spvDescriptorSet3.b10)[2].fence();
    r1.z = as_type<float>((*(constant array<texture_buffer<uint, access::read_write>, 8>*)&spvDescriptorSet3.b10)[2].read(uint(0)).x);
    float4 r2 = (*(constant array<texture2d<float>, 8>*)&spvDescriptorSet2.b20)[0].sample((*(constant array<sampler, 8>*)&spvDescriptorSet2.b20)[3], float2(0.0), level(0.0));
    r2.x = as_type<float>((*(constant array<texture2d<uint>, 8>*)&spvDescriptorSet2.b20)[1].read(uint2(int2(0)), 0).x);
    r2.y = as_type<float>((*(constant array<texture2d<int>, 8>*)&spvDescriptorSet2.b20)[2].read(uint2(int2(0)), 0).x);
    (*(constant array<texture_buffer<uint, access::read_write>, 8>*)&spvDescriptorSet2.b20)[2].fence();
    r2.z = spvDescriptorSet2.b20[3]->v + as_type<float>((*(constant array<texture_buffer<uint, access::read_write>, 8>*)&spvDescriptorSet2.b20)[2].read(uint(0)).x);
    r2.w = b21[4]->v;
    uint i = spvDescriptorSet1.b30[0]->i;
    float4 r3 = t30[i].sample(s30[i + 1u], float2(0.0), level(0.0));
    r3.x = as_type<float>(t31[i + 2u].read(uint2(int2(0)), 0).x);
    r3.y = as_type<float>(t32[i + 3u].read(uint2(int2(0)), 0).x);
    r3.z = b31[i + 5u]->v;
    (*(device array<texture_buffer<uint, access::read_write>, 8>*)&spvDescriptorSet0.t00)[0].write(uint4(0u), uint(0));
    (*(constant array<texture_buffer<uint, access::read_write>, 8>*)&spvDescriptorSet3.b10)[0].write(uint4(0u), uint(0));
    (*(constant array<texture_buffer<uint, access::read_write>, 8>*)&spvDescriptorSet2.b20)[0].write(uint4(0u), uint(0));
    (*(device array<texture_buffer<uint, access::write>, 1>*)&spvDescriptorSet1.b30)[0].write(uint4(0u), uint(0));
}

